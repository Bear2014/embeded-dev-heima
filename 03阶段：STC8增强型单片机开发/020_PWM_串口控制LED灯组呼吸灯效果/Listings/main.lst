C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2025 12:06:16 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "STC8h.h"
   2          #include "lib/Config.h"
   3          #include "lib/STC8G_H_GPIO.h"
   4          #include "lib/STC8G_H_Delay.h"
   5          #include "lib/STC8G_H_NVIC.h"
   6          #include "lib/STC8G_H_Switch.h"
   7          #include "lib/STC8H_PWM.h"
   8          #include "lib/STC8G_H_UART.h"
   9          
  10          void GPIO_Config();
  11          void UART_Config();
  12          void uart1_recv_dat();
  13          
  14          #define LED_SW P45
  15          #define LED1    P27
  16          #define LED2    P26
  17          #define LED3    P15
  18          #define LED4    P14
  19          #define LED5    P23
  20          #define LED6    P22
  21          #define LED7    P21
  22          #define LED8    P20
  23          
  24          #define PERIOD ((MAIN_Fosc / 1000) - 1)
  25          PWMx_Duty  duty;
  26          
  27          /**
  28           * 效果杠杠的
  29           */
  30          
  31          
  32          //PWM配置
  33          void PWM_Config() {
  34   1          PWMx_InitDefine pwm_init;
  35   1        
  36   1          //配置PWM4：对应P27 P26 -->这个配置就是低电平0%
  37   1          pwm_init.PWM_Mode = CCMRn_PWM_MODE2; //底电平
  38   1          pwm_init.PWM_Duty = 0; //关键配置
  39   1          //pwm_init.PWM_Duty = duty.PWM4_Duty;
  40   1          pwm_init.PWM_EnoSelect = ENO4P | ENO4N; //输出通道选择[对应LED1的输出引脚]
  41   1          PWM_Configuration(PWM4,&pwm_init);
  42   1        
  43   1          //配置PWM3:对应P15 P14
  44   1          pwm_init.PWM_Mode = CCMRn_PWM_MODE2;
  45   1          pwm_init.PWM_Duty = 0; //关键配置
  46   1          pwm_init.PWM_EnoSelect = ENO3P | ENO3N;
  47   1          PWM_Configuration(PWM3,&pwm_init);
  48   1        
  49   1          //配置PWM2:对应P23 P22
  50   1          pwm_init.PWM_Mode = CCMRn_PWM_MODE2;
  51   1          pwm_init.PWM_Duty = 0; //关键配置
  52   1          pwm_init.PWM_EnoSelect = ENO2P| ENO2N;
  53   1          PWM_Configuration(PWM2,&pwm_init);
  54   1        
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2025 12:06:16 PAGE 2   

  55   1          //配置PWM1:对应P21 P20
  56   1          pwm_init.PWM_Mode = CCMRn_PWM_MODE1;
  57   1          pwm_init.PWM_Duty = 0; //关键配置
  58   1          pwm_init.PWM_EnoSelect = ENO1P| ENO1N;
  59   1          PWM_Configuration(PWM1,&pwm_init);
  60   1        
  61   1      
  62   1          //配置PWMA!!!!
  63   1          /**
  64   1           * PWM_Period：关键配置!!!!!
  65   1           * 周期时间[一个高电平和一个低电平加在一起占用的时间]，
  66   1           * 可配置范围：0~65535，CPU没有时间的概念，它的 时间概念 等同于 数数 的概念
  67   1           * 假设我们希望在以后计算比较容易，我们打算把周期设置为：1ms[时间]
  68   1           * 这个1ms代表 里面 有高电平 和 低电平的出现
  69   1           **/
  70   1          pwm_init.PWM_Period = PERIOD;
  71   1          pwm_init.PWM_DeadTime = 0; //死区发生器，0~255
  72   1          pwm_init.PWM_CEN_Enable = ENABLE; //使能计数器，ENABLE，DISABLE
  73   1          pwm_init.PWM_MainOutEnable = ENABLE; //主输出使用，ENABLE,DISABLE
  74   1          PWM_Configuration(PWMA,&pwm_init);
  75   1      
  76   1          
  77   1          //切换引脚
  78   1          PWM4_SW(PWM4_SW_P26_P27);
  79   1          PWM3_SW(PWM3_SW_P14_P15);
  80   1          PWM2_SW(PWM2_SW_P22_P23);
  81   1          PWM1_SW(PWM1_SW_P20_P21);
  82   1      
  83   1          
  84   1          //中断使能
  85   1          NVIC_PWM_Init(PWMA,DISABLE,Priority_0);
  86   1      }
  87          
  88          int percent = 0;
  89          int duty_value = 0;
  90          //int direction = 1;
  91          void main() {
  92   1        
  93   1        //配置GPIO
  94   1        GPIO_Config();
  95   1        
  96   1        UART_Config();
  97   1      
  98   1        //打开拓展寄存器使用(pwm专用),且一定要在配置pwm之前打开！！！！！
  99   1        EAXSFR();
 100   1        
 101   1        //配置pwm
 102   1        PWM_Config();
 103   1        
 104   1        //打开全局中断
 105   1        EA = 1;
 106   1        
 107   1        LED_SW = 0;
 108   1        
 109   1        //LED1 = 0;
 110   1        
 111   1        while(1) { //此处也可以改成使用定时器来定时获取数据
 112   2      
 113   2          /*
 114   2          percent += direction;
 115   2          if(percent == 100) {
 116   2            direction = -1;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2025 12:06:16 PAGE 3   

 117   2          } else if(percent == 0){
 118   2            direction = 1;
 119   2          }
 120   2          
 121   2          //更新占空比：参数1：更新哪一个通道或者哪一个组；参数2：占空比的指针变量
 122   2          duty_value = PERIOD * percent / 100; //范围0~PERIOD,此值是一直变化的: PERIOD * 百分比
 123   2      
 124   2          duty.PWM4_Duty = duty_value;
 125   2          duty.PWM3_Duty = duty_value;
 126   2          duty.PWM2_Duty = duty_value;
 127   2          duty.PWM1_Duty = duty_value;
 128   2          UpdatePwm(PWMA, &duty);
 129   2          */
 130   2      
 131   2          
 132   2          uart1_recv_dat();
 133   2          
 134   2          //delay_ms(25); //避免变化太快
 135   2        }
 136   1      
 137   1      }
 138          
 139          void GPIO_Config() {
 140   1        GPIO_InitTypeDef GPIO_InitTypeDef;
 141   1      
 142   1        GPIO_InitTypeDef.Mode = GPIO_OUT_PP;
 143   1        GPIO_InitTypeDef.Pin = GPIO_Pin_5;
 144   1        GPIO_Inilize(GPIO_P4,&GPIO_InitTypeDef);
 145   1        
 146   1        GPIO_InitTypeDef.Mode = GPIO_OUT_PP;
 147   1        GPIO_InitTypeDef.Pin = GPIO_Pin_7 | GPIO_Pin_6 | GPIO_Pin_3 | GPIO_Pin_2 | GPIO_Pin_1 | GPIO_Pin_0;
 148   1        GPIO_Inilize(GPIO_P2,&GPIO_InitTypeDef);
 149   1        
 150   1        GPIO_InitTypeDef.Mode = GPIO_OUT_PP;
 151   1        GPIO_InitTypeDef.Pin = GPIO_Pin_5 | GPIO_Pin_4;
 152   1        GPIO_Inilize(GPIO_P1,&GPIO_InitTypeDef);
 153   1      }
 154          
 155          
 156          //配置串口
 157          void UART_config(void) {
 158   1          COMx_InitDefine   COMx_InitStructure;         //结构定义
 159   1      
 160   1          COMx_InitStructure.UART_Mode      = UART_8bit_BRTx; //模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,U
             -ART_9bit_BRTx
 161   1          COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;     //选择波特率发生器, BRT_Timer1, BRT_Timer2 (注意: 串
             -口2固定使用BRT_Timer2)
 162   1          COMx_InitStructure.UART_BaudRate  = 115200ul;     //波特率, 一般 110 ~ 115200
 163   1          COMx_InitStructure.UART_RxEnable  = ENABLE;       //接收允许,   ENABLE或DISABLE
 164   1          COMx_InitStructure.BaudRateDouble = DISABLE;      //波特率加倍, ENABLE或DISABLE
 165   1          UART_Configuration(UART1, &COMx_InitStructure);   //初始化串口1 UART1,UART2,UART3,UART4
 166   1        
 167   1        
 168   1          NVIC_UART1_Init(ENABLE,Priority_1);   //中断使能, ENABLE\DISABLE; 优先级(低到高) Priority_0,Priority_1,
             -Priority_2,Priority_3
 169   1          
 170   1          UART1_SW(UART1_SW_P30_P31);   //UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44
 171   1      }
 172          
 173          //接收串口数据
 174          void uart1_recv_dat() {
 175   1          u32 duty_value;
C51 COMPILER V9.60.7.0   MAIN                                                              04/09/2025 12:06:16 PAGE 4   

 176   1         
 177   1          if(COM1.RX_Cnt > 0) {
 178   2      
 179   2            if(RX1_Buffer[0] == 0x00) { //led逐渐边亮
 180   3               percent += 1;
 181   3               if(percent > 100) {
 182   4                 percent = 100;
 183   4               }
 184   3            }
 185   2            
 186   2            if(RX1_Buffer[0] == 0x01) { //led逐渐变暗
 187   3               percent -= 1;
 188   3               if(percent < 0) {
 189   4                 percent = 0;
 190   4               }
 191   3            }
 192   2            
 193   2            //已经把数据处理好了，计数就要归0
 194   2            COM1.RX_Cnt = 0;
 195   2            
 196   2            printf("percent: %d \n", (int)percent);
 197   2      
 198   2            duty_value = PERIOD * percent / 100; //范围0~PERIOD,此值是一直变化的: PERIOD * 百分比
 199   2            duty.PWM4_Duty = duty_value;
 200   2            duty.PWM3_Duty = duty_value;
 201   2            duty.PWM2_Duty = duty_value;
 202   2            duty.PWM1_Duty = duty_value;
 203   2            UpdatePwm(PWMA, &duty);
 204   2          }
 205   1      }
 206          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    410    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20      24
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
